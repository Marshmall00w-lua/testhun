
local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not success or not WindUI then
    warn("‚ùå Failed to load WindUI")
    return
end

-- üåà Add all themes
local themeNames = {
    "Ocean Blue","Forest Green","Minimal Light","Retro Purple","Sunset",
    "Neon Pulse","Steel Phantom","Vaporwave","Deep Sea","Sepia Warmth",
    "Monokai Dark","Solarized Light","Cherry Blossom","Charcoal Gold",
    "Icy Mint","Volcano","Amethyst","Pastel Dream","Coffee Shop","Cyberpunk Red"
}

-- Example: Adding all themes
local themeColors = {
    ["Ocean Blue"] = {Accent="#0B5394", Dialog="#0A3D6B", Outline="#6DACEA", Text="#EBF5FF", Placeholder="#85AECF", Background="#051A2E", Button="#1C67A8", Icon="#A9D5FD"},
    ["Forest Green"] = {Accent="#1A5E2E", Dialog="#114220", Outline="#8AC79B", Text="#E9FCE9", Placeholder="#79A378", Background="#0A2B14", Button="#2B7A42", Icon="#B3E3C1"},
    ["Minimal Light"] = {Accent="#F3F4F6", Dialog="#FFFFFF", Outline="#4B5563", Text="#1F2937", Placeholder="#9CA3AF", Background="#F9FAFB", Button="#E5E7EB", Icon="#4B5563"},
    ["Retro Purple"] = {Accent="#7E22CE", Dialog="#4A148C", Outline="#F0ABFC", Text="#FDF4FF", Placeholder="#BC8FDD", Background="#2D0557", Button="#9333EA", Icon="#F0ABFC"},
    ["Sunset"] = {Accent="#FF8847", Dialog="#CC5500", Outline="#FFD9C0", Text="#FFF7F0", Placeholder="#FFC099", Background="#331A00", Button="#FF7043", Icon="#FFD9C0"},
    ["Neon Pulse"] = {Accent="#00FF00", Dialog="#111111", Outline="#00FFFF", Text="#FFFFFF", Placeholder="#008800", Background="#000000", Button="#39FF14", Icon="#00FFFF"},
    ["Steel Phantom"] = {Accent="#404040", Dialog="#262626", Outline="#A3A3A3", Text="#D4D4D4", Placeholder="#737373", Background="#171717", Button="#525252", Icon="#A3A3A3"},
    ["Vaporwave"] = {Accent="#FF00FF", Dialog="#1B001B", Outline="#00FFFF", Text="#FFFFFF", Placeholder="#FF69FF", Background="#0A0014", Button="#E75480", Icon="#00FFFF"},
    ["Deep Sea"] = {Accent="#008B8B", Dialog="#005A5A", Outline="#80CBC4", Text="#E0FFFF", Placeholder="#4DB6AC", Background="#003636", Button="#00A3A3", Icon="#80CBC4"},
    ["Sepia Warmth"] = {Accent="#7B3F00", Dialog="#5C3200", Outline="#D2B48C", Text="#F5E8D6", Placeholder="#A98F70", Background="#3D291F", Button="#9D5B18", Icon="#D2B48C"},
    ["Monokai Dark"] = {Accent="#F92672", Dialog="#272822", Outline="#66D9EF", Text="#F8F8F2", Placeholder="#75715E", Background="#1C1E1A", Button="#A6E22E", Icon="#66D9EF"},
    ["Solarized Light"] = {Accent="#268BD2", Dialog="#FDF6E3", Outline="#93A1A1", Text="#586E75", Placeholder="#839496", Background="#EEE8D5", Button="#B58900", Icon="#268BD2"},
    ["Cherry Blossom"] = {Accent="#F9BCCB", Dialog="#FFFAFD", Outline="#D96985", Text="#4A1429", Placeholder="#C397A3", Background="#FFF7F9", Button="#E68A9F", Icon="#D96985"},
    ["Charcoal Gold"] = {Accent="#FFD700", Dialog="#2C2C2C", Outline="#C0C0C0", Text="#F5F5F5", Placeholder="#6E6E6E", Background="#1D1D1D", Button="#B8860B", Icon="#FFD700"},
    ["Icy Mint"] = {Accent="#40E0D0", Dialog="#F0FFFF", Outline="#81D4FA", Text="#004D40", Placeholder="#B2DFDB", Background="#E0FFFF", Button="#80CBC4", Icon="#40E0D0"},
    ["Volcano"] = {Accent="#B22222", Dialog="#1C1C1C", Outline="#FF6347", Text="#EBEBEB", Placeholder="#704747", Background="#0A0A0A", Button="#FF4500", Icon="#FF6347"},
    ["Amethyst"] = {Accent="#9966CC", Dialog="#36284C", Outline="#CCFF66", Text="#EDE9F2", Placeholder="#8A72A4", Background="#221A33", Button="#7A52AA", Icon="#CCFF66"},
    ["Pastel Dream"] = {Accent="#FFB3BA", Dialog="#FAF3E0", Outline="#BAE1FF", Text="#333333", Placeholder="#C1B4A5", Background="#FFFFFF", Button="#BAE1FF", Icon="#FFB3BA"},
    ["Coffee Shop"] = {Accent="#795548", Dialog="#F5F5DC", Outline="#A1887F", Text="#3E2723", Placeholder="#BCB0A4", Background="#FFF8E1", Button="#D7CCC8", Icon="#795548"},
    ["Cyberpunk Red"] = {Accent="#FF3333", Dialog="#080008", Outline="#33FFFF", Text="#FDFDFD", Placeholder="#771111", Background="#000000", Button="#CC0000", Icon="#33FFFF"}
}

-- Add all themes to WindUI
for name, colors in pairs(themeColors) do
    WindUI:AddTheme({
        Name = name,
        Accent = Color3.fromHex(colors.Accent),
        Dialog = Color3.fromHex(colors.Dialog),
        Outline = Color3.fromHex(colors.Outline),
        Text = Color3.fromHex(colors.Text),
        Placeholder = Color3.fromHex(colors.Placeholder),
        Background = Color3.fromHex(colors.Background),
        Button = Color3.fromHex(colors.Button),
        Icon = Color3.fromHex(colors.Icon)
    })
end

WindUI:SetTheme("Volcano") -- default

local function GradientText(text, color1, color2)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / (#text - 1)
        local r = color1.R + (color2.R - color1.R) * t
        local g = color1.G + (color2.G - color1.G) * t
        local b = color1.B + (color2.B - color1.B) * t
        local hex = string.format("#%02X%02X%02X", r * 255, g * 255, b * 255)
        result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
    end
    return result
end

local Window = WindUI:CreateWindow({
    Title = "RyZen Hub",
    Icon = "rbxassetid://84501312005643",
    IconThemed = true,
    Author = "By @mallo",
    Size = UDim2.fromOffset(580, 460),
    Resizable = true,
    Transparent = true,
    User = {
        Enabled = true,
        Anonymous = False,
        Callback = function()
            print("clicked")
        end,
    },
})

Window:Tag({
    Title = "Tester",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 10, -- from 0 to 13
})

Window:Tag({
    Title = "99 nights",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 10, -- from 0 to 13
})

Window:Tag({
    Title = "Beta",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 10, -- from 0 to 13
})

Window:SetIconSize(50) -- default is 20

Window:EditOpenButton({
    Title = "RyZen Hub",
    Icon = "rbxassetid://84501312005643",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new( -- gradient
        Color3.fromHex("ADD8E6"), 
        Color3.fromHex("00008B")
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

Window:DisableTopbarButtons({ "Close" })

local Info = Window:Tab({Title = "Information", Icon = "info" })

local InviteCode = "KG9ADqwT9Q" -- change to your discord invite
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local Response
local ErrorMessage = nil

xpcall(function()
    Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["Accept"] = "application/json"
        }
    }).Body)
end, function(err)
    warn("err fetching discord info: " .. tostring(err))
    ErrorMessage = tostring(err)
    Response = nil
end)

if Response and Response.guild then
    local ParagraphConfig = {
        Title = Response.guild.name,
        Desc =
            ' <font color="#52525b">‚Ä¢</font> Member Count: ' .. tostring(Response.approximate_member_count) ..
            '\n <font color="#16a34a">‚Ä¢</font> Online Count: ' .. tostring(Response.approximate_presence_count)
        ,
        Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=256",
        ImageSize = 42,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Discord Invite",
                Callback = function()
                    pcall(function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                    end)
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Info",
                Callback = function()
                    xpcall(function()
                        local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
                            Url = DiscordAPI,
                            Method = "GET",
                        }).Body)
                        
                        if UpdatedResponse and UpdatedResponse.guild then
                            DiscordInfo:SetDesc(
                                ' <font color="#52525b">‚Ä¢</font> Member Count: ' .. tostring(UpdatedResponse.approximate_member_count) ..
                                '\n <font color="#16a34a">‚Ä¢</font> Online Count: ' .. tostring(UpdatedResponse.approximate_presence_count)
                            )
                        end
                    end, function(err)
                        warn("err updating discord info: " .. tostring(err))
                    end)
                end
            }
        }
    }
    
    if Response.guild.banner then
        ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. Response.guild.id .. "/" .. Response.guild.banner .. ".png?size=256"
        ParagraphConfig.ThumbnailSize = 80
    end
    
    local DiscordInfo = Info:Paragraph(ParagraphConfig)
else
    Info:Paragraph({
        Title = "Error when receiving information about the Discord server",
        Desc = ErrorMessage or "Unknown error occurred",
        Image = "triangle-alert",
        ImageSize = 26,
        Color = "Red",
    })
end

-- üìò Game Information Box (like ‚ÄúBubble Gum Simulator INFINITY‚Äù)
local GameInfo = Info:Paragraph({
    Title = GradientText("PanScript", Color3.fromRGB(173, 216, 230), Color3.fromRGB(0, 0, 139)),
    Desc = "Script made by @mallo",
    Color = "White",
})

-- üéÆ Supported Games Tab
local SupportedGamesTab = Window:Tab({
    Title = "Supported Games!", 
    Icon = "gamepad",
})

Window:Divider()

-- üè† Main Tab
local MainTab = Window:Tab({
    Title = "Main",
    Icon = "house",
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Wait until RemoteEvents folder exists
local remoteFolder = ReplicatedStorage:WaitForChild("RemoteEvents", 10)
if not remoteFolder then
    warn("‚ùå RemoteEvents folder not found in ReplicatedStorage.")
    return
end

-- Wait until DamagePlayer event exists
local DamageEvent = remoteFolder:WaitForChild("DamagePlayer", 10)
if not DamageEvent then
    warn("‚ùå DamagePlayer event not found in RemoteEvents.")
    return
end

-- God Mode Button
MainTab:Button({
    Title = "God Mode",
    Desc = "Become unkillable instantly",
    Callback = function()
        DamageEvent:FireServer(-math.huge)
        WindUI:Notify({
            Title = "God Mode",
            Content = "You're now invincible!",
            Duration = 3,
            Icon = "rbxassetid://84501312005643",
        })
    end
})

MainTab:Section({
    Icon = "shield",
    Title = "Kill Aura",
})

-- Ensure Settings exist
if type(_G.Settings) ~= "table" then _G.Settings = {} end
if type(_G.Settings.Main) ~= "table" then _G.Settings.Main = {} end

-- Default values
_G.Settings.Main["Kill Aura"] = _G.Settings.Main["Kill Aura"] or false
_G.Settings.Main["Kill Aura Targets"] = _G.Settings.Main["Kill Aura Targets"] or {"All"}
_G.Settings.Main["Kill Aura Range"] = _G.Settings.Main["Kill Aura Range"] or 100

-- Kill Aura Targets
local killAuraTargets = {
    "All","Polar Bear","Arctic Fox","Mammoth","Cultist","Crossbow Cultist",
    "Cultist King","Scorpion","Wolf","Alpha Wolf","Bear","Bunny","Frog",
    "Hellephant","Meteor Crab","Juggernaut King","Alien"
}

MainTab:Dropdown({
    Title = "Kill Aura Targets",
    Description = "Select enemies to Target",
    Values = killAuraTargets,
    Value = {"All"},
    Multi = true,
    AllowNone = true,
    Callback = function(selectedTargets)
        _G.Settings.Main["Kill Aura Targets"] = selectedTargets
    end
})

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- Client module
local client_ok, Client = pcall(function()
    return require(player:WaitForChild("PlayerScripts"):WaitForChild("Client"))
end)

-- Tools
local toolsDamageIDs = {
    ["Old Axe"] = "_1",
    ["Good Axe"] = "_1",
    ["Strong Axe"] = "_1",
    ["Chainsaw"] = "_1",
    ["Laser Sword"] = "_1"
}

local function getToolAndDamageID()
    local inv = player:FindFirstChild("Inventory")
    if not inv then return nil, nil end
    for toolName, suffix in pairs(toolsDamageIDs) do
        local tool = inv:FindFirstChild(toolName)
        if tool then return tool, suffix end
    end
    return nil, nil
end

local function findHRP(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("UpperTorso")
end

local function invokeToolDamage(targetObj, toolObj, damageID, charCFrame)
    if client_ok and Client and Client.Events and Client.Events.ToolDamageObject then
        local ok, res = pcall(function()
            return Client.Events.ToolDamageObject:InvokeServer(targetObj, toolObj, damageID, charCFrame)
        end)
        if ok then return res end
    end
    local fallback = ReplicatedStorage:FindFirstChild("RemoteEvents") and ReplicatedStorage.RemoteEvents:FindFirstChild("ToolDamageObject")
    if fallback and fallback:IsA("RemoteFunction") then
        local ok, res = pcall(function()
            return fallback:InvokeServer(targetObj, toolObj, damageID, charCFrame)
        end)
        if ok then return res end
    end
    return nil
end

local hitCounter = 1

-- Kill Aura Loop
spawn(function()
    while true do
        wait(0.18)
        if _G.Settings.Main["Kill Aura"] and player and player.Character then
            local char = player.Character
            local hrp = findHRP(char)
            local tool, suffix = getToolAndDamageID()
            if hrp and tool and suffix then

                local targets = _G.Settings.Main["Kill Aura Targets"] or {"All"}
                local attackAll = false
                for i, t in pairs(targets) do
                    if t == "All" then attackAll = true end
                end
                local auraRange = tonumber(_G.Settings.Main["Kill Aura Range"]) or 100

                local charactersFolder = Workspace:FindFirstChild("Characters") or Workspace
                local children = charactersFolder:GetChildren()
                for i = 1, #children do
                    local enemy = children[i]
                    if enemy:IsA("Model") and enemy ~= char then
                        local enemyHRP = findHRP(enemy)
                        if enemyHRP and enemy.Parent then
                            local shouldAttack = attackAll
                            if not attackAll then
                                for j, t in pairs(targets) do
                                    if string.lower(t) == string.lower(enemy.Name) then
                                        shouldAttack = true
                                        break
                                    end
                                end
                            end

                            if shouldAttack then
                                local distance = (enemyHRP.Position - hrp.Position).Magnitude
                                if distance <= auraRange then
                                    for k = 1, 10 do
                                        if not _G.Settings.Main["Kill Aura"] or not enemy or not enemy.Parent then break end
                                        local damageID = tostring(hitCounter) .. suffix
                                        local ok, err = pcall(function()
                                            invokeToolDamage(enemy, tool, damageID, hrp.CFrame)
                                        end)
                                        if not ok then
                                            warn("Kill Aura hit failed:", err)
                                        end
                                        hitCounter = hitCounter + 1
                                        wait(0.01)
                                    end
                                end
                            end
                        end
                    end
                end

            end
        end
    end
end)

-- Kill Aura Range Circle
local showRange = false
local ringSegments = 36
local ringParts = {}
local ringFolder = workspace:FindFirstChild("KillAuraRange")
if not ringFolder then
    ringFolder = Instance.new("Folder")
    ringFolder.Name = "KillAuraRange"
    ringFolder.Parent = workspace
end

for i = 1, ringSegments do
    local part = Instance.new("Part")
    part.Size = Vector3.new(0.2, 0.2, 4)
    part.Anchored = true
    part.CanCollide = false
    part.CastShadow = false
    part.Material = Enum.Material.Neon
    part.Color = Color3.fromRGB(255, 0, 0)
    part.Parent = ringFolder
    table.insert(ringParts, part)
end

local function updateCircle(pos, radius)
    for i = 1, #ringParts do
        local part = ringParts[i]
        local angle = (i / #ringParts) * math.pi * 2
        local x = math.cos(angle) * radius
        local z = math.sin(angle) * radius
        part.CFrame = CFrame.new(pos + Vector3.new(x, 0.5, z)) * CFrame.Angles(0, -angle, 0)
    end
end

spawn(function()
    while true do
        wait(0.1)
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            if showRange then
                updateCircle(char.HumanoidRootPart.Position, _G.Settings.Main["Kill Aura Range"])
            else
                for i = 1, #ringParts do
                    ringParts[i].Position = Vector3.new(0, -9999, 0)
                end
            end
        end
    end
end)

-- GUI Toggles
MainTab:Toggle({
    Title = "Kill Aura",
    Desc = "Kill Enemies easily",
    Callback = function(state)
        _G.Settings.Main["Kill Aura"] = state
    end
})

-- Slider & Toggle (unchanged)
MainTab:Slider({
    Title = "Kill Aura Range",
    Desc = "Adjust the range for Kill Aura",
    Step = 1,
    Value = {
        Min = 10,
        Max = 50,
        Default = _G.Settings.Main["Kill Aura Range"],
    },
    Callback = function(value)
        _G.Settings.Main["Kill Aura Range"] = tonumber(value)
    end
})

MainTab:Toggle({
    Title = "Show Kill Aura Range",
    Desc = "Display red circle for Kill Aura",
    Default = false,
    Callback = function(state)
        showRange = state
    end
})


MainTab:Section({
    Icon = "cog",
    Title = "Auto Tame",
})

-- ‚öôÔ∏è Core Services
Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer

-- ü™∂ Auto-Tame Function (resize both SuccessArea & TimingBar)
local function autoTameResize()
    local gui = player:WaitForChild("PlayerGui"):WaitForChild("Interface"):WaitForChild("TamingFluteFrame")
    local timingBar = gui:WaitForChild("TimingBar")
    local successArea = timingBar:WaitForChild("SuccessArea")

    -- Expand SuccessArea and match TimingBar
    successArea.Size = UDim2.new(3, 1, 10.3, 10)
    successArea.Position = UDim2.new(0.5, 0, 0.5, 0)
    timingBar.Size = successArea.Size
    timingBar.Position = successArea.Position
end
-- üß≠ UI Elements (WindUI / Fluent Style)
local Toggle = MainTab:Toggle({
    Title = "Auto Tame",
    Desc = "Automatically completes taming minigame",
    Icon = "target",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        _G.AutoTameEnabled = state
        if state then
            -- Listen for minigame visibility
            local gui = player:WaitForChild("PlayerGui"):WaitForChild("Interface"):WaitForChild("TamingFluteFrame")
            gui:GetPropertyChangedSignal("Visible"):Connect(function()
                if _G.AutoTameEnabled and gui.Visible then
                    autoTameResize()
                end
            end)
        end
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer

-- Helper: get Old Taming Flute from inventory
local function getFlute()
    return player:FindFirstChild("Inventory") and player.Inventory:FindFirstChild("Old Taming Flute")
end

-- Helper: get Old Taming Flute from workspace
local function getFluteFromWorkspace()
    local itemFlute = workspace:FindFirstChild("Items") and workspace.Items:FindFirstChild("Old Taming Flute")
    if not itemFlute then
        for _, child in ipairs(workspace.Items:GetChildren()) do
            if child:FindFirstChild("Main") then
                itemFlute = child.Main
                break
            end
        end
    end
    return itemFlute
end

-- Function to grab the flute
local function grabFlute()
    local flute = getFlute()
    if not flute then
        local itemFlute = getFluteFromWorkspace()
        if itemFlute then
            pcall(function()
                ReplicatedStorage.RemoteEvents.RequestHotbarItem:InvokeServer(itemFlute)
            end)
        else
            -- WindUI notification when no flute found
            pcall(function()
                WindUI:Notify({
                    Title = "Grab Flute",
                    Content = "No Old Taming Flute detected!",
                    Duration = 3,
                    Icon = "bird",
                })
            end)
        end
    else
        -- Already have flute notification
        pcall(function()
            WindUI:Notify({
                Title = "Grab Flute",
                Content = "You already have the flute!",
                Duration = 2,
                Icon = "rbxassetid://84501312005643",
            })
        end)
    end
end

-- MainTab button to manually grab flute
MainTab:Button({
    Title = "Grab Flute Now",
    Callback = grabFlute
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local healEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem")

-- üîß Variables
local autoHealEnabled = false
local healThreshold = 50
local cooldown = false

MainTab:Section({
    Icon = "shield",
    Title = "Auto Heal",
})

MainTab:Toggle({
    Title = "Auto Heal (bandage)",
    Default = false,
    Callback = function(state)
        autoHealEnabled = state
    end
})

local Slider = MainTab:Slider({
    Title = "Heal When Below",
    Desc = "Auto heal when HP drops below this value",
    Step = 1,
    Value = {
        Min = 20,
        Max = 100,
        Default = 70,
    },
    Callback = function(value)
        print("Slider value:", value)
    end
})

-- üîÅ Heal loop
task.spawn(function()
    while task.wait(0.5) do
        if autoHealEnabled and not cooldown then
            local char = player.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")

            if humanoid and humanoid.Health > 0 and humanoid.Health <= healThreshold then
                local inv = player:FindFirstChild("Inventory")
                local bandage = inv and inv:FindFirstChild("Bandage")

                if bandage then
                    healEvent:InvokeServer(bandage)
                    WindUI:Notify({
                        Title = "Auto Heal",
                        Content = "Used Bandage at " .. math.floor(humanoid.Health) .. " HP!",
                        Duration = 3,
                        Icon = "rbxassetid://84501312005643",
                    })
                    cooldown = true
                    task.wait(5)
                    cooldown = false
                else
                    WindUI:Notify({
                        Title = "Auto Heal",
                        Content = "No Bandage found in inventory!",
                        Duration = 3,
                        Icon = "rbxassetid://84501312005643",
                    })
                    task.wait(3)
                end
            end
        end
    end
end)

local BringTab = Window:Tab({
    Title = "Bring Items",
    Icon = "package",
})

local Section = BringTab:Section({ 
    Title = "Settings",
    Icon = "cog",
})

-- Target selection
local BringTarget = "You"

BringTab:Dropdown({
    Title = "Select Target",
    Values = {"You", "Campfire", "Workbench"},
    Value = BringTarget,
    Callback = function(selected)
        BringTarget = selected
        print(" Bring target set to:", BringTarget)
    end
})

-- Max per item variable
local MaxPerItem = 10 -- default

local Input = BringTab:Input({
    Title = "Max Per Item",
    Desc = "Enter how many of each item to bring",
    Value = tostring(MaxPerItem), -- show default value
    InputIcon = "bird",
    Type = "Input", -- single-line input
    Placeholder = "Enter number...",
    Callback = function(input)
        local num = tonumber(input)
        if num and num > 0 then
            MaxPerItem = num
            print("üéöÔ∏è MaxPerItem set to:", MaxPerItem)
        else
            warn("‚ö†Ô∏è Invalid number entered")
        end
    end
})

-- Selected items table
local SelectedItems = {}

-- Full items list with "All" option
local ItemsList = {
    "All", -- special option to select everything
    "Bolt", "Tyre", "Sheet Metal", "Old Radio", "Broken Fan",
    "Broken Microwave", "Washing Machine", "Old Car Engine",
    "UFO Scrap", "UFO Component", "UFO Junk", "Cultist Gem", "Gem of the Forest"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

local Section = BringTab:Section({ 
    Title = "Gears",
    Icon = "cog",
})

-- Selected item variable
local SelectedItem = "Bolt" -- default value

BringTab:Dropdown({
    Title = "Select Gear",
    Values = ItemsList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedItems = {}
            for _, item in ipairs(ItemsList) do
                if item ~= "All" then
                    table.insert(SelectedItems, item)
                end
            end
        else
            SelectedItems = selected
        end
        print("üéØ Selected Items:", table.concat(SelectedItems, ", "))
    end
})

BringTab:Button({
    Title = "Bring Selected Items",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundItems = {} -- store missing items
        local broughtItemsCount = 0 -- total items brought

        for _, itemName in ipairs(SelectedItems) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtItemsCount = broughtItemsCount + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundItems, itemName)
            else
                print("Brought", broughtCount, itemName, "to", BringTarget)
            end
        end

        -- Notify missing items
        if WindUI and #notFoundItems > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find items",
                    Content = table.concat(notFoundItems, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify success
        if WindUI and broughtItemsCount > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Items Brought",
                    Content = "Successfully brought " .. broughtItemsCount .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Fuel",
    Icon = "flame",
})

-- Fuel List (with All)
local FuelList = {
    "All",
    "Corpse", "Sapling", "Alien", "Log", "Chair",
    "Coal", "Fuel Canister", "Oil Barrel", "Biofuel"
}

-- Selected fuel table
local SelectedFuel = {}

BringTab:Dropdown({
    Title = "Select Fuel",
    Values = FuelList,
    Multi = true,
    Value = {},
    Callback = function(selected)
        if table.find(selected, "All") then
            SelectedFuel = {}
            for _, fuel in ipairs(FuelList) do
                if fuel ~= "All" then
                    table.insert(SelectedFuel, fuel)
                end
            end
        else
            SelectedFuel = selected
        end

        print("üî• Selected Fuel:", table.concat(SelectedFuel, ", "))
    end
})

BringTab:Button({
    Title = "Bring Selected Fuel",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 9.5, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundFuel = {}
        local broughtTotal = 0

        for _, fuelName in ipairs(SelectedFuel) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == fuelName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Drag ‚Üí Move ‚Üí Drop
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
broughtTotal = broughtTotal + 1
                                        
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundFuel, fuelName)
            else
                print("üî• Brought", broughtCount, fuelName, "to", BringTarget)
            end
        end

        -- Notify missing fuel
        if WindUI and #notFoundFuel > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Missing Fuel",
                    Content = table.concat(notFoundFuel, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify success
        if WindUI and broughtTotal > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Fuel Delivered",
                    Content = "Successfully brought " .. broughtTotal .. " fuel item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Food & healing",
    Icon = "apple",
})

-- Selected food table
local SelectedFood = {}

-- Full food & healing list with "All" option
local FoodList = {
    "All", -- special option to select everything
    "Carrot", "Berry", "Morsel", "Steak", "Ribs",
    "Cooked Morsel", "Cooked Steak", "Cooked Ribs",
    "Bandage", "Medkit", "Chili"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

-- Food dropdown
BringTab:Dropdown({
    Title = "Select Food & Healing",
    Values = FoodList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedFood = {}
            for _, food in ipairs(FoodList) do
                if food ~= "All" then
                    table.insert(SelectedFood, food)
                end
            end
        else
            SelectedFood = selected
        end
        print("üéØ Selected Food:", table.concat(SelectedFood, ", "))
    end
})

-- Bring Food button
BringTab:Button({
    Title = "Bring Selected Food & Healing",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundFood = {} -- store missing items
        local broughtCountTotal = 0

        for _, foodName in ipairs(SelectedFood) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == foodName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtCountTotal = broughtCountTotal + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundFood, foodName)
            else
                print("‚úÖ Brought", broughtCount, foodName, "to", BringTarget)
            end
        end

        -- Notify missing food
        if WindUI and #notFoundFood > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find food",
                    Content = table.concat(notFoundFood, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify successful brings
        if WindUI and broughtCountTotal > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Food Brought",
                    Content = "Successfully brought " .. broughtCountTotal .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Weapons & ammo",
    Icon = "swords",
})

-- Selected weapons table
local SelectedWeapons = {}

-- Full weapons list with "All" option
local WeaponList = {
    "All", -- special option to select everything
    "Morning star", "Laser Sword", "Raygun", "Chainsaw", "Strong Axe",
    "Spear", "Good Axe", "Revolver", "Rifle", "Tactical Shotgun",
    "Revolver Ammo", "Rifle Ammo", "Alien Armour", "Leather Body",
    "Iron Body", "Thorn Body", "Riot Shield"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

-- Weapon dropdown
BringTab:Dropdown({
    Title = "Select Weapons",
    Values = WeaponList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedWeapons = {}
            for _, weapon in ipairs(WeaponList) do
                if weapon ~= "All" then
                    table.insert(SelectedWeapons, weapon)
                end
            end
        else
            SelectedWeapons = selected
        end
        print("üéØ Selected Weapons:", table.concat(SelectedWeapons, ", "))
    end
})

-- Bring Weapons button
BringTab:Button({
    Title = "Bring Selected Weapons",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundWeapons = {} -- store missing items
        local broughtCountTotal = 0

        for _, weaponName in ipairs(SelectedWeapons) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == weaponName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtCountTotal = broughtCountTotal + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundWeapons, weaponName)
            else
                print("‚úÖ Brought", broughtCount, weaponName, "to", BringTarget)
            end
        end

        -- Notify missing weapons
        if WindUI and #notFoundWeapons > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find weapons",
                    Content = table.concat(notFoundWeapons, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify successful brings
        if WindUI and broughtCountTotal > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Weapons Brought",
                    Content = "Successfully brought " .. broughtCountTotal .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local Section = BringTab:Section({ 
    Title = "Misc",
    Icon = "package",
})

-- Selected others table
local SelectedOthers = {}

-- Full others list with "All" option
local OthersList = {
    "All", -- special option to select everything
    "Sack", "Seed Box", "Chainsaw", "Old Flashlight", "Strong Flastlight",
    "Bunny Foot", "Wolf Pelt", "Bear Pelt", "Alpha Wolf Pet",
    "Artic Fox Pelt", "Polar Bear Pelt", "Mammoth Tusk"
}

-- Stop flag
local StopBring = false

-- Function to get target CFrame
local function GetTargetCFrame()
    if BringTarget == "You" then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            return char.HumanoidRootPart.CFrame
        end
    elseif BringTarget == "Workbench" then
        return CFrame.new(20.9532776, 3.18912888, -5.23712301, -1, 0, 0, 0, 1, 0, 0, 0, -1)
    elseif BringTarget == "Campfire" then
        return CFrame.new(4.95910645e-05, 1.49994469, -7.62939453e-06, -1.1920929e-07, 1.00000012, 0, 1.00000012, -1.1920929e-07, 0, 0, 0, -1.00000024)
    end
end

-- Others dropdown
BringTab:Dropdown({
    Title = "Select Others",
    Values = OthersList,
    Multi = true,  -- Enable multi-selection
    Value = {},    -- start empty
    Callback = function(selected)
        if table.find(selected, "All") then
            -- If "All" is selected, use all items except "All"
            SelectedOthers = {}
            for _, item in ipairs(OthersList) do
                if item ~= "All" then
                    table.insert(SelectedOthers, item)
                end
            end
        else
            SelectedOthers = selected
        end
        print("üéØ Selected Others:", table.concat(SelectedOthers, ", "))
    end
})

-- Bring Others button
BringTab:Button({
    Title = "Bring Selected Others",
    Callback = function()
        local itemsFolder = workspace:FindFirstChild("Items")
        local player = game.Players.LocalPlayer
        local targetPos

        -- Determine target position
        if BringTarget == "You" then
            local char = player.Character
            targetPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position
        elseif BringTarget == "Workbench" then
            targetPos = Vector3.new(20.9532776, 3.18912888, -5.23712301)
        elseif BringTarget == "Campfire" then
            targetPos = Vector3.new(4.95910645e-05, 1.49994469, -7.62939453e-06)
        end

        if not targetPos then
            warn("‚ö†Ô∏è Target not found")
            return
        end

        local notFoundItems = {} -- store missing items
        local broughtItemsCount = 0 -- total items brought

        for _, itemName in ipairs(SelectedOthers) do
            local broughtCount = 0
            local maxBring = MaxPerItem or 10

            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName and item:IsA("Model") then
                    local base = item:FindFirstChildWhichIsA("BasePart")
                    if base then
                        if not item.PrimaryPart then
                            item.PrimaryPart = base
                        end

                        -- Teleport item
                        game.ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                        item:SetPrimaryPartCFrame(CFrame.new(targetPos + Vector3.new(0,3,0)))
                        game.ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)

                        broughtCount = broughtCount + 1
                        broughtItemsCount = broughtItemsCount + 1
                        task.wait(0.05)

                        if broughtCount >= maxBring then
                            break
                        end
                    end
                end
            end

            if broughtCount == 0 then
                table.insert(notFoundItems, itemName)
            else
                print("‚úÖ Brought", broughtCount, itemName, "to", BringTarget)
            end
        end

        -- Notify missing items
        if WindUI and #notFoundItems > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Could not find items",
                    Content = table.concat(notFoundItems, ", "),
                    Duration = 5,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end

        -- Notify successful brings
        if WindUI and broughtItemsCount > 0 then
            pcall(function()
                WindUI:Notify({
                    Title = "Items Brought",
                    Content = "Successfully brought " .. broughtItemsCount .. " item(s) to " .. BringTarget,
                    Duration = 4,
                    Icon = "rbxassetid://84501312005643",
                })
            end)
        end
    end
})

local AutoTab = Window:Tab({
    Title = "Auto",
    Icon = "play",
})

local Section = AutoTab:Section({ 
    Title = "Lost Child",
    Icon = "baby",
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer

-- Campfire CFrame (teleport slightly higher)
local CampfireCFrame = CFrame.new(4.95910645e-05, 9.5, -7.62939453e-06)

-- Sack types
local Sacks = {
    ["Old Sack"] = true,
    ["Good Sack"] = true,
    ["Giant Sack"] = true,
}

-- Map child types to exact model names
local LostChildMap = {
    Dino = "Lost Child",
    Kraken = "Lost Child2",
    Squid = "Lost Child3",
    Koala = "Lost Child4"
}

local LostChildOptions = {"Dino", "Koala", "Kraken", "Squid"}
local SelectedChildren = {}
local CollectedChildren = {} -- track already collected
local PICKUP_DELAY = 1.5

-- GUI Dropdown
local Dropdown = Section:Dropdown({
    Title = "Select Lost Child(s)",
    Desc = "Choose which child(s) to auto pick up",
    Values = LostChildOptions,
    Value = {LostChildOptions[1]},
    Multi = true,
    AllowNone = false,
    Callback = function(option)
        SelectedChildren = option
        print("Selected children: " .. HttpService:JSONEncode(option))
    end
})

-- Check if child is already in ItemBag
local function IsChildInInventory(childType)
    local modelName = LostChildMap[childType]
    local bag = LocalPlayer:FindFirstChild("ItemBag")
    if not bag then return false end
    local category = bag:FindFirstChild(modelName)
    if category and category:FindFirstChild(childType) then
        return true
    end
    return false
end

-- Teleport, pick up, return
local function TeleportAndPickup(childType)
    if IsChildInInventory(childType) then
        CollectedChildren[childType] = true
        WindUI:Notify({
            Title = "Already Found!",
            Content = childType .. " is already in your inventory!",
            Duration = 3,
            Icon = "rbxassetid://84501312005643"
        })
        return
    end

    local Target = nil
    local modelName = LostChildMap[childType]

    for i = 1, 50 do
        Target = Workspace.Characters:FindFirstChild(modelName)
        if Target then break end
        task.wait(0.2)
    end

    if Target then
        local tpCFrame = Target.PrimaryPart and (Target.PrimaryPart.CFrame + Vector3.new(0, 3, 0)) or (Target:GetModelCFrame() + Vector3.new(0, 3, 0))
        LocalPlayer.Character:SetPrimaryPartCFrame(tpCFrame)
        task.wait(0.3)

        local SackName = nil
        for sack, _ in pairs(Sacks) do
            if LocalPlayer.Inventory:FindFirstChild(sack) then
                SackName = sack
                break
            end
        end

        if SackName then
            task.wait(PICKUP_DELAY)
            local success, _ = pcall(function()
                ReplicatedStorage.RemoteEvents.RequestBagStoreItem:InvokeServer(
                    LocalPlayer.Inventory[SackName],
                    Target
                )
            end)

            task.wait(0.8)

            if IsChildInInventory(childType) then
                CollectedChildren[childType] = true
                WindUI:Notify({
                    Title = "Success",
                    Content = "Picked up " .. childType .. "!",
                    Duration = 3,
                    Icon = "rbxassetid://84501312005643"
                })
            else
                CollectedChildren[childType] = false
                WindUI:Notify({
                    Title = "Failed",
                    Content = "Pickup failed for " .. childType .. "!",
                    Duration = 3,
                    Icon = "rbxassetid://84501312005643"
                })
            end

            LocalPlayer.Character:SetPrimaryPartCFrame(CampfireCFrame + Vector3.new(0, 2, 0))
        else
            WindUI:Notify({
                Title = "Error",
                Content = "No sack found!",
                Duration = 3,
                Icon = "rbxassetid://84501312005643"
            })
        end
    else
        WindUI:Notify({
            Title = "Not Found",
            Content = childType .. " model not spawned yet!",
            Duration = 3,
            Icon = "rbxassetid://84501312005643"
        })
    end
end

-- Helper to check if child should be skipped
local function ShouldSkipPickup(childType)
    return CollectedChildren[childType] or IsChildInInventory(childType)
end

-- Auto Pickup Toggle
local AutoPickupEnabled = false

local Toggle = Section:Toggle({
    Title = "Auto Pick Up",
    Desc = "Auto pick up selected Lost Child",
    Icon = "bird",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        AutoPickupEnabled = state
        print("Auto Pick Up Toggle: " .. tostring(state))

        if state then
            spawn(function()
                while AutoPickupEnabled do
                    local allCollected = true

                    for _, childName in pairs(SelectedChildren) do
                        if ShouldSkipPickup(childName) then
                            CollectedChildren[childName] = true
                        else
                            allCollected = false
                            TeleportAndPickup(childName)
                            task.wait(0.5)
                        end
                    end

                    if allCollected then
                        WindUI:Notify({
                            Title = "All Collected",
                            Content = "You have found the selected children!",
                            Duration = 5,
                            Icon = "rbxassetid://84501312005643"
                        })
                        AutoPickupEnabled = false
                        break
                    end

                    task.wait(1)
                end
            end)
        end
    end
})

local Section = AutoTab:Section({ 
    Title = "Auto Sapling",
    Icon = "tree-deciduous", 
})

-- try different signatures for a hit without varargs
local hitCounter = 1
local function tryHitWithCandidate(remote, candidateInst, tree)
    if not remote or not candidateInst or not tree then return false, "missing param" end
    local part = tree.PrimaryPart or tree:FindFirstChildWhichIsA("BasePart")
    if not part then return false, "no basepart" end

    -- build damage candidates from attributes then fallback list
    local dmgVals = {}
    if type(candidateInst.GetAttribute) == "function" then
        local wd = candidateInst:GetAttribute("WeaponDamage")
        if wd ~= nil then table.insert(dmgVals, wd) end
        local rd = candidateInst:GetAttribute("WeaponResourceDamage")
        if rd ~= nil then table.insert(dmgVals, rd) end
    end
    for _, v in ipairs(SETTINGS.TryDamageValues) do table.insert(dmgVals, v) end

    local uniq = {}
    local dmgList = {}
    for _, v in ipairs(dmgVals) do
        local s = tostring(v)
        if not uniq[s] then uniq[s] = true; table.insert(dmgList, v) end
    end
    if #dmgList == 0 then dmgList = { "1" } end

    for _, sig in ipairs(SETTINGS.TrySignatures) do
        for _, dmgV in ipairs(dmgList) do
            local success, info = false, nil
            local args = nil
            if sig == "tool_damage_numeric_cframe" then
                args = { tree, candidateInst, dmgV, (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            elseif sig == "tool_damage_string_cframe" then
                args = { tree, candidateInst, tostring(dmgV), (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            elseif sig == "tool_damage_count_cframe" then
                args = { tree, candidateInst, "1", tostring(hitCounter), (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            else
                args = { tree, candidateInst, tostring(dmgV), (plr.Character and plr.Character:GetPivot()) or CFrame.new(part.Position) }
            end

            local ok, res = safeInvoke(remote, args)
            task.wait(0.12) -- small pause to let server update
            local beforeHealth = nil -- we captured before above? do check now
            -- Note: We intentionally check health after the hit:
            local decreased = healthDecreased(tree:GetAttribute("Health"), tree)
            if decreased == true then
                hitCounter = hitCounter + 1
                return true, ("health decreased with sig "..sig.." dmg="..tostring(dmgV))
            end

            -- also check for drops near the tree
            local pos = (part and part.Position) and part.Position or nil
            local found, dropInfo = waitForDropNear(pos, 0.25, 12)
            if found then
                hitCounter = hitCounter + 1
                return true, ("drop detected with sig "..sig.." dmg="..tostring(dmgV).." drop="..tostring(dropInfo.Name))
            end

            if ok then
                hitCounter = hitCounter + 1
                return true, ("remote call returned ok for sig "..sig.." dmg="..tostring(dmgV))
            end

            task.wait(0.2)
        end
    end

    return false, "exhausted signatures"
end

-- ESP (no varargs)
local espFolder = Workspace:FindFirstChild("TreeHPESP") or Instance.new("Folder", Workspace)
espFolder.Name = "TreeHPESP"
local espMap = {}

local function createESP(tree)
    if espMap[tree] then return end
    local root = tree.PrimaryPart or tree:FindFirstChildWhichIsA("BasePart")
    if not root then return end
    local bb = Instance.new("BillboardGui")
    bb.Name = "AutoCut_HP"
    bb.Adornee = root
    bb.Size = UDim2.new(0,120,0,22)
    bb.StudsOffset = Vector3.new(0,2.2,0)
    bb.AlwaysOnTop = true
    bb.Parent = espFolder
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.fromScale(1,1)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.GothamBold
    lbl.TextScaled = true
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.Parent = bb
    espMap[tree] = { bb = bb, lbl = lbl }
end

local function updateESP(tree)
    if not espMap[tree] then createESP(tree) end
    local info = espMap[tree]
    if not info then return end
    local hp = tree:GetAttribute("Health")
    if hp then
        info.lbl.Text = (tree.Name or "Tree").." | HP: "..tostring(math.floor(tonumber(hp) or hp))
    else
        info.lbl.Text = (tree.Name or "Tree")
    end
    info.bb.Enabled = SETTINGS.ShowHP
end

local function removeAllESP()
    for t, info in pairs(espMap) do
        pcall(function() if info.bb and info.bb.Parent then info.bb:Destroy() end end)
        espMap[t] = nil
    end
end

Workspace.DescendantRemoving:Connect(function(desc)
    if espMap[desc] then
        pcall(function() if espMap[desc].bb and espMap[desc].bb.Parent then espMap[desc].bb:Destroy() end end)
        espMap[desc] = nil
    end
end)

-- MAIN LOOP ‚Äî concurrent tree hits
task.spawn(function()
    while true do
        task.wait(1) -- minimal wait to prevent freezing
        if not SETTINGS.AutoCut then
            task.wait(1)
        else
            local trees = getTreesInRange(SETTINGS.Range)
            if #trees == 0 then
                task.wait(1)
            else
                local candidates = findToolModelCandidates()
                local candidateInst, candidateSrc = pickBestCandidate(candidates)
                if not candidateInst then
                    print("[AutoCut] No tool candidate found. Candidates:", #candidates)
                    task.wait(1)
                else
                    for _, tree in ipairs(trees) do
                        -- spawn each tree hit in its own thread
                        task.spawn(function()
                            if tree and tree.Parent then
                                -- filter by selected types
                                local selected = SETTINGS.Targets or {"All"}
                                local treatAll = false
                                for _, v in ipairs(selected) do
                                    if v == "All" then treatAll = true; break end
                                end
                                local shouldProcess = treatAll
                                if not treatAll then
                                    local lname = (tree.Name or ""):lower()
                                    for _, v in ipairs(selected) do
                                        if lname:find(v:lower()) then
                                            shouldProcess = true
                                            break
                                        end
                                    end
                                end

                                if shouldProcess then
                                    if SETTINGS.ShowHP then updateESP(tree) end
                                    -- try hitting tree with candidate tool
                                    local ok, info = tryHitWithCandidate(TOOL_REMOTE, candidateInst, tree)
                                    print("[AutoCut] Hit result:", tostring(ok), tostring(info))
                                end
                            end
                        end)
                    end
                end
            end
        end
    end
end)

local Dropdown = Section:Dropdown({
        Title="Tree Types",
        Desc="Choose tree types (choosing all might slow down cutting and lags you)",
        Values={"All","Small Tree","Snowy Small Tree","TreeBig1","TreeBig2"," TreeBig3"},
        Value="All",
        Multi=true,
        AllowNone=true,
        Callback=function(sel)
            if type(sel)=="table" and #sel>0 then SETTINGS.Targets = sel else SETTINGS.Targets = {"All"} end
            print("Targets ->", HttpService:JSONEncode(SETTINGS.Targets))
        end
    })

local Input = Section:Input({
    Title = "Range",
    Desc = "Max distance",
    Value = tostring(SETTINGS.Range),
    Callback = function(v)
        local n = tonumber(v)
        if n then
            SETTINGS.Range = math.clamp(n, 1, 2000)
            print("Range ->", SETTINGS.Range)
        end
    end
})

local Toggle = Section:Toggle({
    Title = "Auto Cut",
    Desc = "Enable AutoCut",
    Value = SETTINGS.AutoCut,
    Callback = function(v)
        SETTINGS.AutoCut = not not v
    end
})

local Toggle = Section:Toggle({
    Title = "Show Tree HP",
    Desc = "Toggle Tree HP ESP",
    Value = SETTINGS.ShowHP,
    Callback = function(v)
        SETTINGS.ShowHP = not not v
        if not SETTINGS.ShowHP then
            removeAllESP()
        end
    end
})

print("[AutoCut] Fixed, vararg-free script loaded. SETTINGS:", HttpService:JSONEncode({ Range = SETTINGS.Range, Targets = SETTINGS.Targets }))
Window:Divider()

local Section = AutoTab:Section({ 
    Title = "Collect coins/flowers",
    Icon = "badge-dollar-sign",
})

--========================================================--
--        99 Nights Infinite Auto Collect
--        Coins & Flowers, fast, no ESP
--========================================================--

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer

-- Remotes
local remotesFolder = ReplicatedStorage:FindFirstChild("RemoteEvents") or ReplicatedStorage
local coinRemote = remotesFolder:FindFirstChild("RequestCollectCoints")
                 or remotesFolder:FindFirstChild("RequestCollectCoins")
local flowerRemote = remotesFolder:FindFirstChild("RequestPickFlower")
                   or remotesFolder:FindFirstChild("RequestPickFlowers")

-- State
local State = {
    RunningCoins = false,
    RunningFlowers = false,
    PerItemDelay = 0.05,
    BetweenItems = 0.03,
}

-- Helpers
local function safeNotify(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {Title=title, Text=text, Duration=2})
    end)
    print("[Notify]", title, "-", text)
end

local function safeGetPosition(item)
    if not item then return nil end
    if item:IsA("BasePart") then return item.Position end
    if item.PrimaryPart then return item.PrimaryPart.Position end
    local part = item:FindFirstChildWhichIsA("BasePart", true)
    if part then return part.Position end
    return nil
end

local function callRemoteWithCandidates(remote, item)
    if not remote or not item then return false end
    local candidates = {item}
    if item.Parent then table.insert(candidates, item.Parent) end
    if item.PrimaryPart then table.insert(candidates, item.PrimaryPart) end
    for _,c in ipairs(candidates) do
        local ok,_ = pcall(function()
            if remote.InvokeServer then remote:InvokeServer(c)
            elseif remote.FireServer then remote:FireServer(c)
            end
        end)
        if ok then return true end
    end
    return false
end

local function safeTPToPos(pos)
    if not pos then return end
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if hrp then pcall(function() hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0)) end) end
end

-- Find coins and flowers
local function findCoins()
    local out = {}
    local root = Workspace:FindFirstChild("Items") or Workspace
    for _,v in ipairs(root:GetDescendants()) do
        if (v:IsA("Model") or v:IsA("BasePart")) and v.Name:lower():find("coin") then
            table.insert(out, v)
        end
    end
    return out
end

local function findFlowers()
    local out = {}
    for _,v in ipairs(Workspace:GetDescendants()) do
        if (v:IsA("Model") or v:IsA("BasePart")) and v.Name:lower():find("flower") then
            table.insert(out, v)
        end
    end
    return out
end

-- Infinite collector
local function collectLoop(label, finderFunc, remote, runningFlag)
    task.spawn(function()
        while State[runningFlag] do
            local items = finderFunc()
            for _,item in ipairs(items) do
                if not State[runningFlag] then break end
                local pos = safeGetPosition(item)
                if pos then safeTPToPos(pos) end
                callRemoteWithCandidates(remote, item)
                task.wait(State.PerItemDelay)
            end
            task.wait(State.BetweenItems)
        end
        safeNotify("Auto Collect", label .. " stopped.")
    end)
end

-- Collect functions
local function startCollectCoins()
    if State.RunningCoins then return end
    State.RunningCoins = true
    collectLoop("Coins", findCoins, coinRemote, "RunningCoins")
end

local function stopCollectCoins()
    State.RunningCoins = false
end

local function startCollectFlowers()
    if State.RunningFlowers then return end
    State.RunningFlowers = true
    collectLoop("Flowers", findFlowers, flowerRemote, "RunningFlowers")
end

local function stopCollectFlowers()
    State.RunningFlowers = false
end

--========================================================--
-- BringTab toggles
    local Toggle = Section:Toggle({
    Title="Auto Collect Coins",
    Desc="Collect coins continuously",
    Default=false,
    Callback=function(v)
        if v then
            startCollectCoins()
        else
            stopCollectCoins()
        end
    end
})

local Toggle = Section:Toggle({
    Title="Auto Collect Flowers",
    Desc="Collect flowers continuously",
    Default=false,
    Callback=function(v)
        if v then
            startCollectFlowers()
        else
            stopCollectFlowers()
        end
    end
})

local TeleportTab = Window:Tab({
    Title = "Teleport",
   Icon = "play",
})

local Section = TeleportTab:Section({ 
    Title = "Structure",
    Icon = "map-pin",
})

local structuresFolder = workspace.Map.Landmarks
local npcFolder = workspace.Characters

local structuresList = {
    "Stronghold", "AlienMothership", "Frog Cave", "Military Base",
    "Ice Temple", "Bell Tower", "Research Facility", "Anvil",
    "Snow Clothing Shop", "Fishing Hut", "Volcano", "Cultist Generator Base",
    "Kings Palace"
}

local npcList = {"Fairy", "Caravan", "Bird Watcher", "Pelt Trader"}

-- Selected options
local selectedStructure = structuresList[1]
local selectedNPC = npcList[1]

-- Notify toggle
local notifySpawnToggle = false

-- Track what has already been notified
local notifiedStructures = {}
local notifiedNPCs = {}

-- Function to teleport player
local function teleportTo(pos)
    local plr = game.Players.LocalPlayer
    if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        plr.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
    end
end

-- Structure dropdown + TP button
TeleportTab:Dropdown({
    Title = "Structure",
    Desc = "Select a structure",
    Values = structuresList,
    Value = structuresList[1],
    Callback = function(option)
        selectedStructure = option
    end
})

TeleportTab:Button({
    Title = "TP to Structure",
    Desc = "Teleport to selected structure",
    Callback = function()
        local struct = structuresFolder:FindFirstChild(selectedStructure)
        if struct and struct.PrimaryPart then
            teleportTo(struct.PrimaryPart.Position)
        else
            WindUI:Notify({
                Title = "TP Failed",
                Content = "Structure not spawned or you're too far away!",
                Duration = 3,
                Icon = "warning"
            })
        end
    end
})

TeleportTab:Divider()

local Section = TeleportTab:Section({ 
    Title = "NPC",
    Icon = "user",
})

-- NPC dropdown + TP button
TeleportTab:Dropdown({
    Title = "NPC",
    Desc = "Select an NPC",
    Values = npcList,
    Value = npcList[1],
    Callback = function(option)
        selectedNPC = option
    end
})

TeleportTab:Button({
    Title = "TP to NPC",
    Desc = "Teleport to selected NPC",
    Callback = function()
        local npc = npcFolder:FindFirstChild(selectedNPC)
        if npc and npc.PrimaryPart then
            teleportTo(npc.PrimaryPart.Position)
        else
            WindUI:Notify({
                Title = "TP Failed",
                Content = "NPC not spawned or you're too far away!",
                Duration = 3,
                Icon = "warning"
            })
        end
    end
})

TeleportTab:Divider()

-- Notify toggle
TeleportTab:Toggle({
    Title = "Notify on Spawn",
    Desc = "Notify when structure or NPC spawns",
    Callback = function(state)
        notifySpawnToggle = state
    end
})

-- Spawn detection loop
spawn(function()
    while true do
        -- Structures
        for _, structName in ipairs(structuresList) do
            local struct = structuresFolder:FindFirstChild(structName)
            if struct and not notifiedStructures[structName] then
                notifiedStructures[structName] = true
                if notifySpawnToggle then
                    WindUI:Notify({
                        Title = "Structure Spawned",
                        Content = structName .. " has spawned!",
                        Duration = 3,
                        Icon = "bell"
                    })
                end
            elseif not struct then
                notifiedStructures[structName] = nil -- reset if removed
            end
        end

        -- NPCs
        for _, npcName in ipairs(npcList) do
            local npc = npcFolder:FindFirstChild(npcName)
            if npc and not notifiedNPCs[npcName] then
                notifiedNPCs[npcName] = true
                if notifySpawnToggle then
                    WindUI:Notify({
                        Title = "NPC Spawned",
                        Content = npcName .. " has spawned!",
                        Duration = 3,
                        Icon = "person"
                    })
                end
            elseif not npc then
                notifiedNPCs[npcName] = nil -- reset if removed
            end
        end

        wait(1)
    end
end)

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "compass", -- optional
    Locked = false,
})

MiscTab:Section({
    Title = "Themes",
    Desc = "Select Your Themes.",
    Color = "Blue"
})

-- üé® Theme Dropdown
local ThemeDropdown = MiscTab:Dropdown({
    Title = "Select Theme",
    Values = themeNames,
    Value = "Volcano",
    Callback = function(selectedTheme)
        WindUI:SetTheme(selectedTheme)
    end
})

-- ü™ü Transparent Window Toggle
MiscTab:Toggle({
    Title = "Transparent Window",
    Desc = "Toggle UI transparency on or off",
    Default = false, -- starts off
    Callback = function(state)
        if state then
            Window:ToggleTransparency(true)
        else
            Window:ToggleTransparency(false)
        end
    end
})